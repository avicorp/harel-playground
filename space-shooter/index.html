<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Space Shooter</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; background: #000; }
</style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const player = { x: 400, y: 550, w: 40, h: 40, color: 'cyan' };
const bullets = [];
const enemies = [];
const powerUps = [];
let lastEnemySpawn = 0;
let lastPowerUpSpawn = 0;
let score = 0;

function spawnEnemy() {
  enemies.push({ x: Math.random() * 760, y: -40, w: 40, h: 40, color: 'red' });
}

function spawnPowerUp() {
  powerUps.push({ x: Math.random() * 760, y: -20, w: 20, h: 20, color: 'yellow' });
}

function update(delta) {
  // Move bullets
  for (const b of bullets) b.y -= 400 * delta;
  // Remove off-screen bullets
  while (bullets.length && bullets[0].y < -20) bullets.shift();
  // Move enemies
  for (const e of enemies) e.y += 100 * delta;
  // Remove off-screen enemies
  while (enemies.length && enemies[0].y > 620) enemies.shift();
  // Move power-ups
  for (const p of powerUps) p.y += 80 * delta;
  while (powerUps.length && powerUps[0].y > 620) powerUps.shift();

  // Collision detection
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    // Enemy vs player
    if (rectsOverlap(e, player)) {
      alert('Game over! Score: ' + score);
      document.location.reload();
      return;
    }
    // Enemy vs bullets
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (rectsOverlap(e, b)) {
        enemies.splice(i, 1);
        bullets.splice(j, 1);
        score += 10;
        break;
      }
    }
  }

  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    if (rectsOverlap(p, player)) {
      powerUps.splice(i, 1);
      score += 50;
    }
  }

  // Spawning
  if (performance.now() - lastEnemySpawn > 1000) {
    spawnEnemy();
    lastEnemySpawn = performance.now();
  }

  if (performance.now() - lastPowerUpSpawn > 5000) {
    spawnPowerUp();
    lastPowerUpSpawn = performance.now();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawRect(player);
  bullets.forEach(drawRect);
  enemies.forEach(drawRect);
  powerUps.forEach(drawRect);
  ctx.fillStyle = 'white';
  ctx.fillText('Score: ' + score, 10, 20);
}

function drawRect(obj) {
  ctx.fillStyle = obj.color;
  ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

let lastTime = performance.now();
function gameLoop() {
  const now = performance.now();
  const delta = (now - lastTime) / 1000;
  update(delta);
  draw();
  lastTime = now;
  requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') player.x -= 20;
  if (e.key === 'ArrowRight') player.x += 20;
  if (e.key === ' ') {
    bullets.push({ x: player.x + player.w / 2 - 5, y: player.y, w: 10, h: 20, color: 'lime' });
  }
});

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
